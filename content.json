{"posts":[{"title":"为什么不可以emplace_back({1, 2})?","text":"为什么不可以emplace_back({1, 2})?在cpp代码中，我们可以写出如下的代码： 12vector&lt;pair&lt;int, int&gt;&gt; vec;vec.push_back({1, 2}); 然而，vec.emplace_back({1, 2})会报错，我们只能vec.push_back(1, 2)。 why push_back works?对于void push_back( T&amp;&amp; value )，由于下面这两条规则，我们可以使用一个braced-init-list作为函数的参数。 https://timsong-cpp.github.io/cppwp/n4868/dcl.init.list#1.5 https://timsong-cpp.github.io/cppwp/n4868/dcl.init.list#3.7 由于下面这一条规则，我们最终找到了这一条构造函数 https://timsong-cpp.github.io/cppwp/n4868/over.match#list-1.2 why emplace_back not works with a braced-list?对于vec.emplace_back(1, 2)，只是一个std::forward参数转发，vector会调用allocator_trait的construct函数执行一个placement new来构造参数。 https://en.cppreference.com/w/cpp/container/vector/emplace_back 而对于vec.emplace_back({1, 2})，由于emplace_back的函数签名是 在cpp中，由于以下的规则，不支持在函数参数中由一个大括号的参数把一个完全空白的模版参数T推断成完整的initializer_list，如果把emplace_back的参数改为initializer_list则可行。 谜题解开了。","link":"/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E4%BB%A5emplace_back(%7B1,%202%7D)?-bd9047ba9ae8/"}],"tags":[],"categories":[],"pages":[]}