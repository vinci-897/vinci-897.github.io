{"posts":[{"title":"为什么不可以emplace_back({1, 2})?","text":"在cpp代码中，我们可以写出如下的代码： 12vector&lt;pair&lt;int, int&gt;&gt; vec;vec.push_back({1, 2}); 然而，vec.emplace_back({1, 2})会报错，我们只能vec.emplace_back(1, 2)。 why push_back works?对于void push_back( T&amp;&amp; value )，由于下面这两条规则，我们可以使用一个braced-init-list作为函数的参数（所谓的braced-init-list就是大括号）。 https://vinci-897.github.io/cppwp/n4868/dcl.init.list#1.5 https://vinci-897.github.io/cppwp/n4868/dcl.init.list#3.7 由于下面这一条规则，我们最终找到了这一条构造函数 https://vinci-897.github.io/cppwp/n4868/over.match#list-1.2 why emplace_back not works with a braced-list?对于vec.emplace_back(1, 2)，只是一个std::forward参数转发，vector会调用allocator_trait的construct函数执行一个placement new来构造参数。 https://en.cppreference.com/w/cpp/container/vector/emplace_back 而对于vec.emplace_back({1, 2})，由于emplace_back的函数签名是 在cpp中，由于以下的规则，不支持在函数参数中由一个大括号的参数把一个完全空白的模版参数T推断成完整的initializer_list&lt;int&gt;，因此clang会给出类似template deduction failed的报错(然而auto是支持这种推导的），如果把emplace_back的参数改为initializer_list&lt;T&gt;则可行。 谜题解开了。","link":"/why-emplace_back-not-works/"},{"title":"volatile in c&#x2F;cpp","text":"volatile的行为对于c/cpp中的volatile关键字，标准中有如下规定： https://vinci-897.github.io/cppwp/n4868/dcl.type.cv#6 https://en.cppreference.com/w/cpp/language/cv 从上述规定中可以看出，volatile关键字的存在主要是避免编译器对这一变量进行有侵略性的优化，volatile变量的访问1不能够被优化掉，2也不能够被和其他volatile变量的访问之间变换顺序。个人认为，前者主要是指以下情况： 12int x = 1;cout &lt;&lt; x; 在这种情况中，x可能被外部状态改变，如MMIO中硬件状态改变、信号处理函数改变、可能被汇编实现的setjmp/longjmp改变等，但编译器在优化时只考虑作为单线程运行的流程，因此可能会让cout直接输出1。（也可能是被其他线程改变，但是本文讨论的volatile不能阻止多线程的问题） 1234int x = 0;while(x) { cout &lt;&lt; 123;} 同样的原因，编译器可能会直接删除掉while循环，或者在while中只使用寄存器中存储的x值。 123456789int x = 1;void sig_handler(int signum) { x = 0;}int main() { while(x) { cout &lt;&lt; 123; }} 代码可能会被编译成一个while(true)的死循环，或者在while中只使用寄存器中存储的x值，编译器不会考虑x被内存中的signal_handler修改的情况，所以即使信号被触发，也不会跳出循环。因此，volatile可以被用于以下几种情况：与硬件进行MMIO交互/信号处理函数修改/内联汇编，可以发现，正如标准中所说的那样，volatile可以阻止编译器的这种行为，告知编译器这一变量可能被本部分代码流程之外的行为修改。 volatile不应该被用于多线程共享变量在上述的内容中，我们提到，其他线程的修改也会导致编译器的优化变得不再正确，那么我们能否通过使用volatile变量解决多线程之间变量修改的同步呢？。我们知道，除了在将c/cpp语言编译成机器语言代码时，会被编译器改变其执行顺序之外，cpu在执行时还会对指令进行乱序执行，这种优化在单线程时会保证访存结果与乱序前相同，然而对于多核来说，可能不再正确。同时，刚刚说到，cpu在访问内存时还会使用cache，多核之间的cache可能会不同步，导致不同线程看到的变量修改顺序不同，虽然缓存一致性协议能够保证多核缓存的同步，但是由于大多数cpu并没有实现完美的缓存一致性协议，而是保留了自己的内存模型（因此他们也提供了内存屏障指令），并且存在store buffer一类的延迟写入策略(store buffer问题的相关介绍)，因此缓存不同步依然会导致多个线程在访问内存上的同一地址时得到各自缓存中不同的值。这几个问题导致我们即使阻止了编译器优化对操作顺序的影响，也不能阻止cpu乱序执行和cache的影响（这两个问题需要内存屏障来解决），然而volatile只能解决编译器的问题，volatile不会被编译为内存屏障指令，因此volatile无法解决多线程之间变量的同步问题。 内存屏障","link":"/volatile-in-cpp/"}],"tags":[],"categories":[],"pages":[]}